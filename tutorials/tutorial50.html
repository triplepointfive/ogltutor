<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <!--[if lt IE 9]><script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <title>Уроки по OpenGL с сайта OGLDev - Урок 50 - Введение в Vulkan</title>
    <meta name="keywords" content />
    <meta name="description" content />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script type="text/javascript" src="../js/shCore.js"></script>
    <script type="text/javascript" src="../js/shBrushCpp.js"></script>
    <script type="text/javascript" src="../js/highlight.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/style.css" />
    <link rel="stylesheet" type="text/css" href="../css/foundation.css" />
    <link rel="stylesheet" type="text/css" href="../css/normalize.css" />
    <link type="text/css" rel="stylesheet" href="../css/shCoreDefault.css" />
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-35259428-1', 'auto');
        ga('send', 'pageview');

    </script>
</head>

<body>
    <div class="row header">
        <div class="large-12 columns">
            <div class="nav-bar right">
                <ul class="button-group">
                    <li><a href="../" class="button nav-left">Содержание</a></li>
                    <li><a href="../instr.html" class="button">Инструкции</a></li>
                    <li><a href="../cont.html" class="button nav-right">Контакты</a></li>
                </ul>
            </div>
            <h1><small>Уроки по OpenGL с сайта OGLDev</small></h1>
            <hr>
        </div>
    </div>

    <div class="row">
        <div class="large-12 columns">
            <div class="tutorial">
    <h2>
        <a href="http://ogldev.atspace.co.uk/www/tutorial50/tutorial50.html">Урок 50 - Введение в Vulkan</a>
    </h2>
    <p>Думаю, вы как минимум слышали об <a href="https://www.khronos.org/vulkan/">Vulkan API</a> - новом графическом API от Khronos (некоммерческая организация разрабатывающая OpenGL). Vulkan был анонсирован в феврале 2016, через 24 года после OpenGL, и является полностью новым стандартом и уходом от текущей модели. Я не буду глубоко вдаваться в отличия Vulkan, а только скажу, что он в разы более низкоуровневый чем OpenGL, и даёт разработчику большой контроль над производительностью. Но с большой силой приходит и большая ответственность. Разработчик должен взять под контроль самые разные аспекты, например, буфер команд, синхронизацию и управление памятью; ранее этим занимался драйвер. Но благодаря тому, что разработчик детально знает структуру собственного приложения, Vulkan API может быть использован таким образом, чтобы увеличить общую производительность.</p>
<p>На мой взгляд, больше всего в Vulkan людей шокирует то, сколько требуется написать кода только для того, что бы вывести на экран первый треугольник. В первых уроках по OpenGL требуется буквально пара строк, но здесь, для многих, желающих начать цикл статей по Vulkan, это становится целым испытанием. Поэтому, как и всегда для OGLDEV, я начну представлять материал по шагам. Мы выведем первый треугольник за пару уроков, понемногу продвигаясь в каждом. Кроме того, я постараюсь не вываливать дюжину вызовов API в одном длинном куске кода, а сразу начну заворачивать в приложение с простым дизайном, который, я надеюсь, пригодится вам для будущих приложений. Но в любом случае, это обучающее приложение, и не стесняйтесь его изменять под себя.</p>
<p>Двигаясь по коду мы будем поочередно изучать ключевые компоненты Vulkan, поэтому сейчас я просто хочу представить общую диаграмму:</p>
<div class="figure">
<img src="../images/50/vulkan.jpg" alt />

</div>
<p>Эта диаграмма ни в коем случае не претендует на полноту. Она содержит только основные компоненты, которые будут использоваться в большинстве приложений. Связи между компонентами обозначают зависимости в момент создания, либо перечисления. Например, для создания поверхности требуется экземпляр объекта, а когда вы перечисляете физические устройства в системе, то также требуется экземпляр. Два цвета объясняют наш дизайном в общих чертах. Красный объединяет то, что я бы назвал “ядром”, а зелёный те части, которые будут “приложением”. Позже мы разберем для чего это нужно. Код самого приложения, которое вы будете писать, будет наследоваться от “приложения”, и все его части будут вам доступны для использования. Очень надеюсь, что этот дизайн поможет нам в разработке следующих частей этого цикла по Vulkan.</p>
<h3 id="подготовка-системы"><strong>Подготовка системы</strong></h3>
<p>Первое что нам нужно, это проверить, что система поддерживает Vulkan, и всё подготовить к разработке. Вы должны проверить, что ваша видеокарта поддерживает Vulkan, и установить свежие драйвера. Так как Vulkan ещё совсем недавно вышел в свет, то лучше почаще проверять обновления драйверов, там могут быть исправления ошибок. Поскольку существует огромное число GPU, я не могу подробно рассказать о каждом. Обновление / установка драйверов под Windows не должна вызвать затруднений. Под Linix могут потребоваться некоторые танцы с бубном. Для разработки я использую Linux Fedora с видеокартой GT710 от NVIDIA на борту. NVIDIA предоставляет один бинарный файл, который может быть установлен только из командной строки. У других производителей всё может быть иначе. Под Linux вы можете использовать <em>lspci</em> для скана системы и поиска своего GPU. Попробуйте добавить опции <em>-v</em>, <em>-vv</em> и <em>-vvv</em> чтобы увидеть больше деталей.</p>
<p>Далее нам потребуется установить Vulkan SDK от компании Khronos, скачать который можно <a href="https://vulkan.lunarg.com/">по ссылке</a>. SDK помимо заголовочных файлов и библиотек включает в себя большое число примеров, которые вы можете использовать для лучшего ознакомления с возможностями API. На момент написания урока, актуальная версия SDK 1.0.30.0, и я призываю вас регулярно проверять обновления, так как SDK сейчас находится в активной разработке. В нескольких следующих разделах версия будет указываться в командах в явном виде, так что не забывайте изменять её на ту, которую вы устанавливаете.</p>
<h3 id="linux">Linux</h3>
<p>Khronos предоставляет запускаемый файл предназначенный для Ubuntu. После запуска он устанавливает всё что требуется, но при запуске под Fedora я столкнулся с некоторыми сложностями. Я использовал следующие команды:</p>
<ul>
<li>bash$ chmod +x vulkansdk-linux-x86_64-1.0.30.0.run</li>
<li>base$ ./vulkansdk-linux-x86_64-1.0.30.0.run <strong>–target</strong> VulkanSDK-1.0.30.0 <strong>–noexec</strong></li>
<li>base$ ln -s ~/VulkanSDK-1.0.30/1.0.30.0 ~/VulkanSDK</li>
</ul>
<p>Эти команды извлекают содержимое пакета без запуска внутренних скриптов. После распаковки директория <em>VulkanSDK-1.0.30.0</em> будет содержать каталог <em>1.0.30.0</em> с файлами пакета. Предположим, что я запускал эти команды находясь в домашнем каталоге (известном как <em>~</em>), тогда мы получим символьную ссылку <em>~/VulkanSDK</em> на каталог с содержимым пакета (с каталогами <em>source</em>, <em>samples</em>, и т.д.). Ссылка упрощает переключение среды разработки на более свежую версию. По ссылке можно получить библиотеки и заголовочные файлы. Чуть позднее мы разберемся с тем, как их использовать. А пока что сделайте следующее:</p>
<ul>
<li>bash$ cd VulkanSDK/1.0.30.0</li>
<li>bash$ ./build_examples.sh</li>
</ul>
<p>Если всё прошло успешно, то примеры были собраны в <em>examples/build</em>. Для их запуска вы должны <em>cd</em> в этот каталог. А теперь попробуйте запустить <em>./cube</em> и <em>./vulkaninfo</em> чтобы убедиться, что Vulkan запускается на вашей системе, и получить информацию о драйвере.</p>
<p>Надеюсь, что всё прошло успешно, так что мы можем добавить немного символических ссылок, чтобы удобнее обращаться к файлам, которые нам требуются при разработке. Зайдите под суперпользователем (с помощью вызова <em>su</em> и ввода пароля) и запустите команды:</p>
<ul>
<li>bash# ln -s /home/&lt;your username&gt;/VulkanSDK/x86_x64/include/vulkan /usr/include</li>
<li>base# ln -s /home/&lt;your username&gt;/VulkanSDK/x86_x64/lib/libvulkan.so.1 /usr/lib64</li>
<li>base# ln -s /usr/lib64/libvulkan.so.1 /usr/lib64/libvulkan.so</li>
</ul>
<p>С помощью этих трёх команд мы добавили символические ссылки из <em>/usr/include</em> в каталог заголовочных файлов Vulkan. Кроме того, мы добавили ссылки на динамические библиотеки, которые будут использоваться при линковке. Теперь, если мы обновили SDK, то нам требуется только изменить ссылку <em>~/VulkanSDK</em> на местоположение новой версии. Отметим, что вызов команд из-под рута требуется только один раз. После обновления SDK потребуется изменить ссылку только в домашнем каталоге. Вы, конечно, можете дать ссылке любое имя, но код, который идет с моими уроками, предполагает, что она находится в домашнем каталоге.</p>
<h3 id="windows">Windows</h3>
<p>Установка под Windows ощутимо проще чем под Linux. Просто скачайте последнюю версию <a href="https://vulkan.lunarg.com/sdk/home#windows">здесь</a>, дважды кликните по файлу установщика, согласитесь со всем, что вам предложат, выберите директорию установки, и, в общем-то, всё. Я бы предложил установить SDK в <em>c:\VulkanSDK</em> для обеспечения совместимости с моим проектом Visual Studio. Если вы устанавливаете куда-то ещё, то не забудьте обновить в проекте директории с заголовочными файлами и библиотеками. Детали вы найдете в следующем разделе.</p>
<h3 id="сборка-и-запуск"><strong>Сборка и запуск</strong></h3>
<h3 id="linux-1">Linux</h3>
<p>Под Linux я в основном разрабатываю в <a href="http://www.netbeans.org/">Netbeans</a>. Код, который идет с уроками, содержит проекты сборки Netbeans для C/C++. Если вы установили SDK как я написал выше, то эти проекты должны работать их коробки (и, пожалуйста, сообщите мне о любых проблемах). Если вы используете другую систему сборки, убедитесь, что вы добавили:</p>
<ul>
<li>В команду компиляции: <strong>-I&lt;path to VulkanSDK/1.0.30.0/x86_64/include&gt;</strong></li>
<li>В команду линковки: <strong>-L&lt;path to VulkanSDK/1.0.30.0/x86_64/lib&gt; -lxcb -lvulkan’</strong></li>
</ul>
<p>Даже если вы не используете Netbeans, вы всё ещё можете скомпилировать урок командой <em>make</em>. Netbeans самостоятельно генерирует Makefile. Этого будет достаточно, чтобы проверить настройку системы. Для этого скачайте <a href="http://ogldev.org/ogldev-source.zip">исходники</a>, разархивируйте их, зайдете в каталог <em>ogldev/tutorial50</em>, а затем запустите команду <em>make</em>. Если вы всё сделали правильно, то вы можете запустить <em>dist/Debug/GNU-Linux-x86/tutorial50</em> из <em>ogldev/tutorial50</em>.</p>
<h3 id="windows-1">Windows</h3>
<p>Если вы установили SDK в <em>c:\VulkanSDK</em>, то мои проекты Visual Studio должны работать прямо из коробки. Если же нет, или вы хотите создать новый проект Visual Studio, то сделайте так:</p>
<p>Для обновления каталога с заголовочными файлами нажмите на проект в окошке <em>solution explorer</em>, перейдите в <em>Properties</em>, а затем в <em>Configuration Properties -&gt; C/C++ -&gt; General</em>. Теперь вы должны добавить <em>c:\VulkanSDK\&lt;version&gt;\Include</em> в <em>Additional Include Directories</em>. Пример приведен ниже:</p>
<div class="figure">
<img src="../images/50/include.jpg" alt />

</div>
<p>Для обновления каталога с файлами библиотеки нажмите правой кнопкой мыши на проект в окошке <em>solution explorer</em>, перейдите в <em>Properties</em> и затем в <em>Configuration Properties -&gt; Link -&gt; General</em>. Теперь вы должны добавить <em>c:\VulkanSDK\&lt;version&gt;\Bin32</em> в поле <em>Additional Library Directories</em>. Пример приведен ниже:</p>
<div class="figure">
<img src="../images/50/link.jpg" alt />

</div>
<p>Пока вы ещё настраиваете линковщик зайдите в <em>Input</em> (сразу же под <em>General</em>), а затем добавьте <em>vulkan-1.lib</em> в поле <em>Additional Dependencies</em>.</p>
<h3 id="общие-комментарии"><strong>Общие комментарии</strong></h3>
<p>Прежде чем мы перейдем к коду, я бы хотел отметить некоторые мои решения о дизайне приложений с использованием Vulkan.</p>
<ol style="list-style-type: decimal">
<li><p>Многие функции в Vulkan (особенно те, которые создают объекты) принимают на вход параметр - структуру. Такая структура используется как обертка над большей частью параметров, которые нужны функции. Благодаря этому у функций ощутимо меньше входящих параметров. Разработчики Vulkan решили, что первым параметром у таких структур будет свойство <em>sType</em>. Оно имеет перечислимый тип, и для каждой структуры свой код. Это позволяет драйверу определять тип структуры, зная только её адрес. У каждого кода есть префикс <strong>VK_STRUCTURE_TYPE_</strong>. Например, код структуры используемой при создании экземпляра <strong>VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO</strong>.</p>
<p>Каждый раз когда я объявляю переменную с типом одной из этих структур, первое что я делаю, это обновляю значение <em>sType</em>. Для экономии бумаги в дальнейшем я не буду это упоминать.</p></li>
<li><p>Ещё одно важное замечание об этих структурах - у них очень много свойств, которые нас пока не волнуют. Что бы код был компактнее (а уроки короче…) я всегда буду инициализировать структуры нулями (с помощью нотации <strong>struct = {}</strong>) и в явном виде обозначать только те свойства, которые не могут быть нулями. Я объясню их в следующих уроках, когда эти свойства будут востребованы.</p></li>
<li><p>В Vulkan функции либо являются процедурами, либо возвращают код ошибки в объекте <strong>VkResult</strong>. Код ошибки является перечислением, где <strong>VK_SUCCESS</strong> равно 0, а все остальные коды ошибок больше 0. По мере возможностей я добавляю проверку на ошибки. Если возникла ошибка, то я вывожу сообщение в консоль (а в Window в отдельном окошке) и выхожу. Обработка ошибок в реальном приложении слишком усложняет код, а моя задача сохранить простоту.</p></li>
<li><p>Многие функции Vulkan (особенно те, которые создают объекты) принимают на вход функцию выделения памяти. Такой подход позволяет контролировать процесс выделения памяти Vulkan. На мой взгляд это тема для уже опытных разработчиков, поэтому мы не будем заморачиваться с этим и всегда будем передавать NULL. В этом случае драйвер будет использовать свою функцию по умолчанию.</p></li>
<li><p>Vulkan не гарантирует экспорт своих функций в библиотеке. Это значит, что на некоторых платформах вы можете получить <em>segmentation fault</em> при вызове функции Vulkan так как она оказалась равна NULL. В этом случае вы вынуждены использовать <strong>vkGetInstanceProcAddr()</strong> для получения адреса функции перед её использованием (вспомнил, что в OpenGL для этой проблемы мы использовали GLEW). В моем случае только vkCreateDebugReportCallbackEXT() была не доступна. Эта функция требуется только для дополнительной проверочной прослойки. Поэтому, я решил рискнуть и для всех функций которые я использую в уроке не получать адресов. Если поступят жалобы, то я обновлю код урока.</p></li>
<li><p>Каждое серьезное приложение обязано позаботиться об освождении память, иначе не избежать утечек. В этом уроке я не стал усложнять и не уничтожанию никакие объекты. В любом случае они удалятся при завершении программы. В будущем я, возможно, ещё вернусь к этой теме, но пока просто запомните, что почти все функции вида &lt;<strong>vkCreate<em>()<strong> имеет в пару </strong>vkDestroy</em>()</strong>. И будьте осторожны при удалении объектов пока программа ещё работает. Больше деталей вы найдете по <a href="https://www.khronos.org/registry/vulkan/specs/1.0-wsi_extensions/xhtml/vkspec.html#fundamentals-objectmodel-overview">ссылке</a>.</p></li>
</ol>
<h3 id="структура-проекта"><strong>Структура проекта</strong></h3>
<p>Далее приведен краткий перечень файлов, которые мы собираемся обозревать.</p>
<ol style="list-style-type: decimal">
<li><p><strong>tutorial50/tutorial50.cpp</strong> - здесь определена функция <em>main()</em>.</p></li>
<li><p><strong>include/ogldev_vulkan.h</strong> - основной заголовочный и единственный файл в котором загружаются заголовочные файлы Vulkan. Вы можете включить проверочную прослойку раскоментив <strong>ENABLE_DEBUG_LAYERS</strong>. Этот файл содержит несколько вспомогательных функций и макросов, а так же определение класса <strong>VulkanWindowControl</strong>.</p></li>
<li><p><strong>Common/ogldev_vulkan.cpp</strong> - реализация функций, определённых в <em>ogldev_vulkan.h</em>.</p></li>
<li><p><strong>include/ogldev_vulkan_core.h</strong> - объявление главного класса <strong>OgldevVulkanCore</strong> в котором сосредоточена вся суть.</p></li>
<li><p><strong>Common/ogldev_vulkan_core.cpp</strong> - реализация класса <strong>OgldevVulkanCore</strong>.</p></li>
<li><p><strong>include/ogldev_xcb_control.h</strong> - объявление класса <strong>XCBControl</strong>, который создает окно в Linux.</p></li>
<li><p><strong>Common/ogldev_xcb_control.cpp</strong> - реализация <strong>XCBControl</strong>.</p></li>
<li><p><strong>include/ogldev_win32_control.h</strong> - объявление класса <strong>Win32Control</strong>, который создает окно в Windows.</p></li>
<li><p><strong>Common/ogldev_win32_control.cpp</strong> - реализация <strong>Win32Control</strong>.</p></li>
</ol>
<p>Как в Netbeans, так и в Visual Studio файлы разделены между проектами <em>tutorial50</em> и <em>Common</em>.</p>
<h2 id="прямиком-к-коду"><a href="https://github.com/triplepointfive/ogldev/tree/master/tutorial50">Прямиком к коду!</a></h2>
<p>Я надеюсь, что вы справились с первой частью и теперь полностью готовы погрузиться в Vulkan. Как я уже говорил, мы собираемся разработать наше первое демо приложение в несколько этапов. Первым шагом будет настроить самые основные объекты Vulkan: экземпляр, поверхность, физическое и логическое устройства. Я буду объяснять следуя моему дизайну приложения, но вы вольны пропустить эту часть и изучать только обращения к Vulkan.</p>
<p>В самом начале мы включаем заголовки Vulkan. В моем проекте все файлы Vulkan включаются только в файле <em>ogldev_vulkan.h</em>. Поэтому во всём остальном проекте включается только этот файл. Вот соответствующие куски кода:</p>
<pre><code>#ifdef _WIN32
#define VK_USE_PLATFORM_WIN32_KHR
#include &quot;vulkan/vulkan.h&quot;
#include &quot;vulkan/vk_sdk_platform.h&quot;
#else
#define VK_USE_PLATFORM_XCB_KHR
#include &lt;vulkan/vulkan.h&gt;
#include &lt;vulkan/vk_sdk_platform.h&gt;
#endif</code></pre>
<p>Обратите внимание на то, что мы добавили различные макросы для Windows и Linux. Эти макросы включают дополнения для поддержки оконной системы для каждой ОС. Причина, по которой включение заголовков отличается кавычками, в том, что в Linux эти файлы устанавливаются в системный каталог (<strong>/usr/include/vulkan</strong>), а в Windows в стандартный каталог.</p>
<p>Давайте начнем ревью с класса <strong>OgldevVulkanCore</strong>, который отвечает за создание и работу с основными объектами.</p>
<pre><code>class OgldevVulkanCore
{
public:
    OgldevVulkanCore(const char* pAppName);
    ~OgldevVulkanCore();

    bool Init(VulkanWindowControl* pWindowControl);

    const VkPhysicalDevice&amp; GetPhysDevice() const;

    const VkSurfaceFormatKHR&amp; GetSurfaceFormat() const;

    const VkSurfaceCapabilitiesKHR GetSurfaceCaps() const;

    const VkSurfaceKHR&amp; GetSurface() const { return m_surface; }

    int GetQueueFamily() const { return m_gfxQueueFamily; }

    VkInstance&amp; GetInstance() { return m_inst; }

    VkDevice&amp; GetDevice() { return m_device; }

private:
    void CreateInstance();
    void CreateSurface();
    void SelectPhysicalDevice();
    void CreateLogicalDevice();

    // Объекты Vulkan
    VkInstance m_inst;
    VkDevice m_device;
    VkSurfaceKHR m_surface;
    VulkanPhysicalDevices m_physDevices;

    // Внутрение детали
    std::string m_appName;
    int m_gfxDevIndex;
    int m_gfxQueueFamily;
};</code></pre>
<p>Помимо вектора объектов Vulkan <em>m_physDevices</em> (инициирован будет далее), класс включает в себя три свойства Vulkan (<em>m_inst</em>, <em>surface</em> и <em>m_device</em>). Кроме того, мы храним название приложения, индекс используемого физического устройства и индекс набора очередей. Класс также содержит несколько методов чтения и функцию Init(), которая всё настраивает. Давайте разберёмся, что же она делает.</p>
<pre><code>void OgldevVulkanCore::Init(VulkanWindowControl* pWindowControl)
{
    std::vector&lt;VkExtensionProperties&gt; ExtProps;
    VulkanEnumExtProps(ExtProps);

    CreateInstance();

    #ifdef WIN32
    assert(0);
    #else
    m_surface = pWindowControl-&gt;CreateSurface(m_inst);
    assert(m_surface);
    #endif
    printf(&quot;Surface created\n&quot;);

    VulkanGetPhysicalDevices(m_inst, m_surface, m_physDevices);
    SelectPhysicalDevice();
    CreateLogicalDevice();
}</code></pre>
<p>Эта функция принимает на вход объект <em>VulkanWindowControl</em>. Мы потом разберёмся с этим объектом. Пока что достаточно сказать, что это ОС зависимый класс, задача которого - это создание оконной поверхности, на которую будет происходить рендер. Совсем как и в OpenGL, ядро Vulkan не содержит работы с окнами. Эта задача отдана расширениям, и у нас есть полный набор для всех основных ОС. Участники Khronos могут публиковать свои собственные расширения в общем <a href="https://www.khronos.org/registry/vulkan/">регистре</a>. Разработчики драйверов сами решают какие из разрешений они хотят реализовывать. А уже пользователи Vulkan могут во время работы приложения смотреть в список доступных разрешений и решать что с ними делать.</p>
<p>Мы начнем с перечисления всех расширений. Происходит это в следующей функции - декораторе:</p>
<pre><code>void VulkanEnumExtProps(std::vector&lt;vkextensionproperties&gt;&amp; ExtProps)
{
    uint NumExt = 0;
    VkResult res = vkEnumerateInstanceExtensionProperties(NULL, &amp;NumExt, NULL);
    CHECK_VULKAN_ERROR(&quot;vkEnumerateInstanceExtensionProperties error %d\n&quot;, res);

    printf(&quot;Found %d extensions\n&quot;, NumExt);

    ExtProps.resize(NumExt);

    res = vkEnumerateInstanceExtensionProperties(NULL, &amp;NumExt, &amp;ExtProps[0]);
    CHECK_VULKAN_ERROR(&quot;vkEnumerateInstanceExtensionProperties error %d\n&quot;, res);

    for (uint i = 0 ; i &lt; NumExt ; i++) {
        printf(&quot;Instance extension %d - %s\n&quot;, i, ExtProps[i].extensionName);
    }
}</code></pre>
<p>Функция выше обрамляет вызов <strong>vkEnumerateInstanceExtensionProperties()</strong> к Vulkan API, который возвращает доступные в системе расширения. То, как мы используем это функцию, очень распространено в Vulkan. Первый вызов возвращает количество расширений. Это число мы используем для задания размера вектора расширений. Второй вызов уже возвращает сами расширения. Первый параметр позволяет выбрать прослойку. Vulkan устроен таким образом, что производители видеокарт могут добавлять логические прослойки для валидации, дополнительная отладочная печать и прочее. Во время работы приложения мы вольны выбирать, какой из слоев включить. Например, во время разработки включить слой с проверками данных, а при распространении приложения уже отключать. Так как нам нужны все расширения, то мы передаем NULL в качестве слоя.</p>
<p>После получения списка расширений мы печатаем их. Если вы хотите произвести какие-то действия со списком расширений, то эту логику можно добавить сюда. Печать списка расширений позволит убедиться в том, что требуемые далее расширения включены в этот список. Следующий этап инициализации заключается в создании экземпляра Vulkan:</p>
<pre><code>void OgldevVulkanCore::CreateInstance()
{
    VkApplicationInfo appInfo = {};
    appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
    appInfo.pApplicationName = m_appName.c_str();
    appInfo.engineVersion = 1;
    appInfo.apiVersion = VK_API_VERSION_1_0;

    const char* pInstExt[] = {
#ifdef ENABLE_DEBUG_LAYERS
        VK_EXT_DEBUG_REPORT_EXTENSION_NAME,
#endif
        VK_KHR_SURFACE_EXTENSION_NAME,
#ifdef _WIN32
        VK_KHR_WIN32_SURFACE_EXTENSION_NAME,
#else
        VK_KHR_XCB_SURFACE_EXTENSION_NAME
#endif
    };

#ifdef ENABLE_DEBUG_LAYERS
    const char* pInstLayers[] = {
        &quot;VK_LAYER_LUNARG_standard_validation&quot;
    };
#endif

    VkInstanceCreateInfo instInfo = {};
    instInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    instInfo.pApplicationInfo = &amp;appInfo;
#ifdef ENABLE_DEBUG_LAYERS
    instInfo.enabledLayerCount = ARRAY_SIZE_IN_ELEMENTS(pInstLayers);
    instInfo.ppEnabledLayerNames = pInstLayers;
#endif
    instInfo.enabledExtensionCount = ARRAY_SIZE_IN_ELEMENTS(pInstExt);
    instInfo.ppEnabledExtensionNames = pInstExt;

    VkResult res = vkCreateInstance(&amp;instInfo, NULL, &amp;m_inst);
    CHECK_VULKAN_ERROR(&quot;vkCreateInstance %d\n&quot;, res);

#ifdef ENABLE_DEBUG_LAYERS
    // Получаем адрес функции vkCreateDebugReportCallbackEXT
    my_vkCreateDebugReportCallbackEXT = reinterpret_cast&lt;pfn_vkcreatedebugreportcallbackext&gt;(vkGetInstanceProcAddr(m_inst, &quot;vkCreateDebugReportCallbackEXT&quot;));

    // Регистрируем функцию отладки
    VkDebugReportCallbackCreateInfoEXT callbackCreateInfo;
    callbackCreateInfo.sType       = VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT;
    callbackCreateInfo.pNext       = NULL;
    callbackCreateInfo.flags       = VK_DEBUG_REPORT_ERROR_BIT_EXT |
                                     VK_DEBUG_REPORT_WARNING_BIT_EXT |
                                     VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT;
    callbackCreateInfo.pfnCallback = &amp;MyDebugReportCallback;
    callbackCreateInfo.pUserData   = NULL;

    VkDebugReportCallbackEXT callback;
    res = my_vkCreateDebugReportCallbackEXT(m_inst, &amp;callbackCreateInfo, NULL, &amp;callback);
    CheckVulkanError(&quot;my_vkCreateDebugReportCallbackEXT error %d\n&quot;, res);
#endif
}</code></pre>
<p>Для инициализации библиотеки Vulkan мы должны создать экземпляр - объект <strong>VkInstance</strong>. Этот объект хранит состояние приложения. Функция, которая создает его, называется <strong>vkCreateInstance()</strong>, и ей требуется большая часть свойств структуры <strong>VkInstanceCreateInfo</strong>. Интересующие нас параметры, это список расширений и (дополнительно) список слоев, которые мы хотим включить. Из расширений это расширение общей поверхности и расширение для ОС зависимой поверхности. Слои и расширения определяются через их название - строку, а для некоторых из них Khronos SDK предлагает макрос. <strong>VkInstanceCreateInfo</strong> также принимает указатель на структуру <strong>VkApplicationInfo</strong>. Эта структура содержит свойства приложения, а разработчик может задать название и некоторую внутреннюю версию движка. Свойство VkApplicationInfo, на которое стоит обратить внимание, это <em>apiVersion</em>. Это задает минимальную версию Vulkan, которая требуется приложению. Если в системе установлена версия меньше, то этот вызов упадет. Мы запрашиваем версию 1.0, так что всё должно быть в порядке.</p>
<p>После того как в наши руки попадёт экземпляр мы сможем зарегистрировать в проверяющим слое функцию, которая будет печатать предупреждения и сообщения об ошибках. Для этого получаем указатель на функцию <strong>vkCreateDebugReportCallbackEXT</strong>, затем мы заполняем структуру <strong>VkDebugReportCallbackCreateInfoEXT</strong> флагами о тех аспектах, о которых драйвер должен нас уведомлять, и указателем на нашу функцию отладки. В действительности регистрация происходит при вызове функции, указатель которой мы получили ранее. Мы получаем указатель на функцию <strong>vkCreateDebugReportCallbackEXT</strong> и наша функция обратного вызова для отладки имеет следующий вид:</p>
<pre><code>PFN_vkCreateDebugReportCallbackEXT my_vkCreateDebugReportCallbackEXT = NULL;

VKAPI_ATTR VkBool32 VKAPI_CALL MyDebugReportCallback(
    VkDebugReportFlagsEXT       flags,
    VkDebugReportObjectTypeEXT  objectType,
    uint64_t                    object,
    size_t                      location,
    int32_t                     messageCode,
    const char*                 pLayerPrefix,
    const char*                 pMessage,
    void*                       pUserData)
{
    printf(&quot;%s\n&quot;, pMessage);
    return VK_FALSE;    // Т.к. мы не хотим чтобы вызывающая функция упала.
}</code></pre>
<p>Далее мы создадим оконную поверхность. Для этого мы воспользуемся объектом <strong>VulkanWindowControl</strong>, указатель на который получает функция <em>Init()</em>. С этим классом мы познакомимся позднее, поэтому не будем на нём сейчас останавливаться (обратите внимание на то, что для создания поверхности используется экземпляр; поэтому мы и создаём объекты в этом порядке).</p>
<p>После создания экземпляра и поверхности мы готовы к получению информации об физических устройствах системы. Под физическим устройством мы понимаем либо дискретную, либо интегрированную видеокарту. Например, ваш компьютер может иметь несколько видеокарт NVIDIA с технологией SLI и графический GPU Intel HD, встроенный в CPU. В этом случае у вас три физических устройства. Функция ниже получает все физические устройства и некоторые их характеристики в виде структуры <strong>VulkanPhysicalDevices</strong>. Структура, по сути, представляет собой базу данных физических устройств и их свойств. Она состоит из нескольких векторов (иногда векторов векторов) объектов Vulkan. Для получения доступа к конкретному устройству вы должны получить индекс устройства и с ним обращаться к вектору. То есть, для получения информации о физическом устройстве с индексом 2 обращайтесь к <em>m_device[2]</em> и <em>m_devProps[2]</em>, и так далее. Причина, по которой я выбрал такую структуру (а не один объект на устройство), в том, что это совпадает с форматом API Vulkan. Вы предоставляете массив XYZ и получаете все XYZ объекты для всех физических устройств. Вот определение этой схожей с базой данных структуры:</p>
<pre><code>struct VulkanPhysicalDevices {
    std::vector&lt;VkPhysicalDevice&gt; m_devices;
    std::vector&lt;VkPhysicalDeviceProperties&gt; m_devProps;
    std::vector&lt; std::vector&lt;VkQueueFamilyProperties&gt; &gt; m_qFamilyProps;
    std::vector&lt; std::vector&lt;VkBool32&gt; &gt; m_qSupportsPresent;
    std::vector&lt; std::vector&lt;VkSurfaceFormatKHR&gt; &gt; m_surfaceFormats;
    std::vector&lt;VkSurfaceCapabilitiesKHR&gt; m_surfaceCaps;
};</code></pre>
<p>Теперь давайте рассмотрим функцию заполнения базы данных. Первых два параметра представляют собой экземпляр и поверхность. Третий параметр это то, куда будут записаны данные. Мы будем изучать функцию по частям.</p>
<pre><code>void VulkanGetPhysicalDevices(const VkInstance&amp; inst, const VkSurfaceKHR&amp; Surface, VulkanPhysicalDevices&amp; PhysDevices)
{
    uint NumDevices = 0;

    VkResult res = vkEnumeratePhysicalDevices(inst, &amp;NumDevices, NULL);
    CHECK_VULKAN_ERROR(&quot;vkEnumeratePhysicalDevices error %d\n&quot;, res);
    printf(&quot;Num physical devices %d\n&quot;, NumDevices);</code></pre>
<p>Вначале мы должны получить число физических устройств. И снова мы видим систему из двух вызовов - первый для получения количества элементов, а второй для получения уже самих значений.</p>
<pre><code>    PhysDevices.m_devices.resize(NumDevices);
    PhysDevices.m_devProps.resize(NumDevices);
    PhysDevices.m_qFamilyProps.resize(NumDevices);
    PhysDevices.m_qSupportsPresent.resize(NumDevices);
    PhysDevices.m_surfaceFormats.resize(NumDevices);
    PhysDevices.m_surfaceCaps.resize(NumDevices);</code></pre>
<p>Мы можем изменить размер базы данных таким образом, чтобы вмещать все элементы.</p>
<pre><code>    res = vkEnumeratePhysicalDevices(inst, &amp;NumDevices, &amp;PhysDevices.m_devices[0]);
    CHECK_VULKAN_ERROR(&quot;vkEnumeratePhysicalDevices error %d\n&quot;, res);</code></pre>
<p>И ещё раз этот вызов, но уже с адресом вектора <em>VkPhysicalDevice</em>. Очень удобно использовать векторы из стандартной библиотеки, так как они функционируют как обычные массивы - адрес первого элемента и есть адрес самого вектора. С нашей точки зрения <strong>VkPhysicalDevice</strong> представляет собой идентификатор физического устройства. Давайте теперь составим цикл по числу физических устройств и для каждого из них получим больше информации.</p>
<pre><code>    for (uint i = 0 ; i &lt; NumDevices ; i++) {
        const VkPhysicalDevice&amp; PhysDev = PhysDevices.m_devices[i];
        vkGetPhysicalDeviceProperties(PhysDev, &amp;PhysDevices.m_devProps[i]);</code></pre>
<p>Мы начинаем с получения свойств текущего устройства. <em>m_devProps</em> - это вектор <strong>VkPhysicalDeviceProperties</strong>. Эта структура содержит такую информацию об устройстве, как название, версия, ID и прочее. При помощи следующих вызовов <em>printf</em> мы выводим на печать некоторые из этих свойств:</p>
<pre><code>        printf(&quot;Device name: %s\n&quot;, PhysDevices.m_devProps[i].deviceName);
        uint32_t apiVer = PhysDevices.m_devProps[i].apiVersion;
        printf(&quot;    API version: %d.%d.%d\n&quot;, VK_VERSION_MAJOR(apiVer),
                                          VK_VERSION_MINOR(apiVer),
                                          VK_VERSION_PATCH(apiVer));</code></pre>
<p>После этого мы получаем свойства всех наборов очередей, которые есть у устройства. GPU может выполнять всего четыре вида операций:</p>
<ol style="list-style-type: decimal">
<li><p>Графические - 2D/3D рендер (как и OpenGL).</p></li>
<li><p>Вычислять - общий вычислительный процесс, который никак не связан с рендером. Используется, например, для параллельных вычислений, без какого-либо отношения к 3D.</p></li>
<li><p>Перемещать - копирование буферов и изображений.</p></li>
<li><p>Управление фрагментированной памятью, т.е. которая не смежна. Эти команды помогают разобраться с ней.</p></li>
</ol>
<p>Задачи, которые мы отправляем устройству, выполняются по очереди. Устройство предоставвляет один или несколько наборов очередей, и каждый из них содержит одну и более очередей. У каждого набора своя комбинация из четырёх типов приведенных выше. Очереди в каждом наборе имеют общую функциональность. Например, мой GPU имеет два набора: первый состоит из 16 очередей и принимает все четыре типа команд. А второй только из одной очереди, которая поддерживает лишь перемещение. Это полезно для архитектурно-зависимых трюков по улучшению производительности приложения.</p>
<pre><code>        uint NumQFamily = 0;

        vkGetPhysicalDeviceQueueFamilyProperties(PhysDev, &amp;NumQFamily, NULL);

        printf(&quot;    Num of family queues: %d\n&quot;, NumQFamily);

        PhysDevices.m_qFamilyProps[i].resize(NumQFamily);
        PhysDevices.m_qSupportsPresent[i].resize(NumQFamily);

        vkGetPhysicalDeviceQueueFamilyProperties(PhysDev, &amp;NumQFamily, &amp;(PhysDevices.m_qFamilyProps[i][0]));</code></pre>
<p>В коде выше мы получили число свойств у набора текущего устройства, изменили размер <em>m_qFamilyProps</em> и <em>m_qSupportsPresent</em> (оба являются векторами векторов, так что мы обязаны сначала выбрать текущее устройство), а затем мы получили и записали в базу вектор свойств.</p>
<pre><code>        for (uint q = 0 ; q &lt; NumQFamily ; q++) {
            res = vkGetPhysicalDeviceSurfaceSupportKHR(PhysDev, q, Surface, &amp;(PhysDevices.m_qSupportsPresent[i][q]));
            CHECK_VULKAN_ERROR(&quot;vkGetPhysicalDeviceSurfaceSupportKHR error %d\n&quot;, res);
        }</code></pre>
<p>Пока мы ещё говорим про наборы очередей, давайте пройдёмся по каждому набору и проверим, поддерживает ли он вывод на экран. <strong>vkGetPhysicalDeviceSurfaceSupportKHR()</strong> принимает на вход физическое устройство, поверхность, индекс набора очередей и возвращает флаг - может ли такая комбинация из устройства и набора выводить на поверхность.</p>
<pre><code>        uint NumFormats = 0;
        vkGetPhysicalDeviceSurfaceFormatsKHR(PhysDev, Surface, &amp;NumFormats, NULL);
        assert(NumFormats &gt; 0);

        PhysDevices.m_surfaceFormats[i].resize(NumFormats);

        res = vkGetPhysicalDeviceSurfaceFormatsKHR(PhysDev, Surface, &amp;NumFormats, &amp;(PhysDevices.m_surfaceFormats[i][0]));
        CHECK_VULKAN_ERROR(&quot;vkGetPhysicalDeviceSurfaceFormatsKHR error %d\n&quot;, res);

        for (uint j = 0 ; j &lt; NumFormats ; j++) {
            const VkSurfaceFormatKHR&amp; SurfaceFormat = PhysDevices.m_surfaceFormats[i][j];
            printf(&quot;    Format %d color space %d\n&quot;, SurfaceFormat.format , SurfaceFormat.colorSpace);
        }</code></pre>
<p>На очереди формат поверхности. Каждая поверхность поддерживает не менее одного формата. Формат просто определяет то, как данных используются поверхностью. В целом, формат указывает на каналы каждого пикселя и тип канала (float, int, …). Например, <em>VK_FORMAT_R32G32B32_SFLOAT</em> задает три канала (красный, зелёный и синий) из 32-х битного типа с плавающей запятой. Формат поверхности очень важен так как он определяет то, как данные будут использоваться или конвертироваться в различных операциях (например отображение на экран). Для получения формата нам нужны как поверхность, так и физическое устройство так как они могут получиться несовместимыми. Мы снова используем вектор векторов поскольку форматов поверхностей может быть доступно сразу несколько штук. Формат нам понадобится позже, поэтому сейчас мы записываем его в базу данных. Теперь давайте получим свойства поверхности:</p>
<pre><code>        res = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(PhysDev, Surface, &amp;(PhysDevices.m_surfaceCaps[i]));
        CHECK_VULKAN_ERROR(&quot;vkGetPhysicalDeviceSurfaceCapabilitiesKHR error %d\n&quot;, res);

        VulkanPrintImageUsageFlags(PhysDevices.m_surfaceCaps[i].supportedUsageFlags);
    }
}</code></pre>
<p>Структура <strong>VkSurfaceCapabilitiesKHR</strong> описывает свойства физического устройства в рамках конкретной поверхности. Они включают в себя минимальное и максимальное количество изображений, которые могут входить в цепочку изображений, минимальный и максимальный размер участка, который может быть отрендерен, поддерживаемые повороты и прочее. Для каждой пары физического устройства и поверхности у нас по одной структуре, все они хранятся в векторе <em>m_surfaceCaps</em>.</p>
<p>Ух, наконец-то мы получили всю информацию о физических устройствах! (Ещё раз, некоторые из этих свойств зависят от выбранной поверхности). Следующий шаг в функции <em>Init()</em> - это выбор одного из физических устройств и одной из очередей для начала обработки. Следующая функция занимается как раз этим:</p>
<pre><code>void OgldevVulkanCore::SelectPhysicalDevice()
{
    for (uint i = 0 ; i &lt; m_physDevices.m_devices.size() ; i++) {

        for (uint j = 0 ; j &lt; m_physDevices.m_qFamilyProps[i].size() ; j++) {
            VkQueueFamilyProperties&amp; QFamilyProp = m_physDevices.m_qFamilyProps[i][j];

            printf(&quot;Family %d Num queues: %d\n&quot;, j, QFamilyProp.queueCount);
            VkQueueFlags flags = QFamilyProp.queueFlags;
            printf(&quot;    GFX %s, Compute %s, Transfer %s, Sparse binding %s\n&quot;,
                    (flags &amp; VK_QUEUE_GRAPHICS_BIT) ? &quot;Yes&quot; : &quot;No&quot;,
                    (flags &amp; VK_QUEUE_COMPUTE_BIT) ? &quot;Yes&quot; : &quot;No&quot;,
                    (flags &amp; VK_QUEUE_TRANSFER_BIT) ? &quot;Yes&quot; : &quot;No&quot;,
                    (flags &amp; VK_QUEUE_SPARSE_BINDING_BIT) ? &quot;Yes&quot; : &quot;No&quot;);

            if (flags &amp; VK_QUEUE_GRAPHICS_BIT) {
                if (!m_physDevices.m_qSupportsPresent[i][j]) {
                    printf(&quot;Present is not supported\n&quot;);
                    continue;
                }

                m_gfxDevIndex = i;
                m_gfxQueueFamily = j;
                printf(&quot;Using GFX device %d and queue family %d\n&quot;, m_gfxDevIndex, m_gfxQueueFamily);
                break;
            }
        }
    }

    if (m_gfxDevIndex == -1) {
        printf(&quot;No GFX device found!\n&quot;);
        assert(0);
    }
}</code></pre>
<p>В более сложных приложениях вам могут понадобиться несколько очередей на нескольких устройствах, но пока давайте сделаем проще. Вложенный цикл в этой функции проходит по списку устройств и списку наборов очередей для каждого устройства. Мы ищем устройство и очередь, которые поддерживают графические команды и способны вывести графику на ту поверхность, для которой была заполнена база данных. Когда мы найдем подходящее устройство и набор, мы сохраним их индексы и выйдем из цикла. Эта пара из устройства и набора будет использоваться на протяжении всего урока. Если подходящей пары не найдено, то приложение будет завершено. Это означает, что система не удовлетворяем минимальным требованиям для работы приложения.</p>
<p>Всё что нам осталось, это инициализировать ядро и создать логическое устройство:</p>
<pre><code>void OgldevVulkanCore::CreateLogicalDevice()
{
    float qPriorities = 1.0f;
    VkDeviceQueueCreateInfo qInfo = {};
    qInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
    qInfo.queueFamilyIndex = m_gfxQueueFamily;
    qInfo.queueCount = 1;
    qInfo.pQueuePriorities = &amp;qPriorities;

    const char* pDevExt[] = {
        VK_KHR_SWAPCHAIN_EXTENSION_NAME
    };

    VkDeviceCreateInfo devInfo = {};
    devInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
    devInfo.enabledExtensionCount = ARRAY_SIZE_IN_ELEMENTS(pDevExt);
    devInfo.ppEnabledExtensionNames = pDevExt;
    devInfo.queueCreateInfoCount = 1;
    devInfo.pQueueCreateInfos = &amp;qInfo;

    VkResult res = vkCreateDevice(GetPhysDevice(), &amp;devInfo, NULL, &amp;m_device);

    CHECK_VULKAN_ERROR(&quot;vkCreateDevice error %d\n&quot;, res);

    printf(&quot;Device created\n&quot;);
}</code></pre>
<p>Vulkan разделяет понятия физического устройства, как части реальной системы, от логического устройства как абстракции над ним. Логическое устройство - это то, что используем в приложении для создания большей части объектов зависящих от устройства (очереди, цепочки изображений и прочее). Такая архитектура добавляет гибкости в управлении устройствами. Логическое устройство позволяет нам давать доступ только к отдельным аспектам физического устройства. Например, если физическое устройство поддерживает и графику и вычисления, то мы можем дать доступ только к графике через логическое устройство.</p>
<p>Для создания устройства нам понадобится одна структура <strong>VkDeviceCreateInfo</strong> и ещё одна <strong>VkDeviceQueueCreateInfo</strong>. <em>VkDeviceCreateInfo</em> главная часть определения устройства. В этой структуре мы назначаем указатель на массив расширений, которые хотим использовать. Нам нужно включить цепочки изображений, так как они определены в расширениях, а не в ядре. Цепочка изображений - это массив изображений поверхностей, которые могут быть нарисованы. Нам также нужен размер массива расширений. Далее нам нужен указатель на массив структур <strong>VkDeviceQueueCreateInfo</strong> (и его размер). Для каждого набора очередей, который мы хотим использовать, потребуется одна структура <strong>VkDeviceQueueCreateInfo</strong>. Эта структура содержит индекс набора очередей (который мы получили ранее в <em>SelectPhysicalDevice()</em>), число требуемых нам очередей, и для каждой очереди мы можем указать приоритет. В этом уроке мы не будем задавать приоритеты, т.к. очередь у нас одна и приоритет у неё 1.0.</p>
<p>На этом завершается инициализация класса <strong>OgldevVulkanCore</strong>, но для вызова метода <em>Init()</em> нам нужен <strong>VulkanWindowControl</strong> - класс, который я добавил для декорации управления оконной поверхности. Вспомним, что эта часть не относится к ядру Vulkan, и так как для каждой ОС требуется свой код, то я решил разделить на классы всю работу с окнами. Сам класс является интерфейсом и определён следующим образом:</p>
<pre><code>class VulkanWindowControl
{
protected:
    VulkanWindowControl() {};

    ~VulkanWindowControl() {};

public:

    virtual bool Init(uint Width, uint Height) = 0;

    virtual VkSurfaceKHR CreateSurface(VkInstance&amp; inst) = 0;
};</code></pre>
<p>Как вы можете заметить, этот класс крайне прост. У него нет никаких свойств. Так как его конструктор и деструктор имеют модификатор доступа <em>protected</em>, то нельзя создать экземпляры этого класса напрямую. Есть два публичных метода. Один для инициализации объекта, и второй для создания поверхности Vulkan. Таким образом для каждой ОС мы вольны в своих действиях, главное - это вернуть объект <strong>VkSurfaceKHR</strong>. Таким образом, мы можем инициализировать этот класс перед созданием <strong>VulkanCoreObject</strong>, но нам требуется инициализировать <strong>VulkanCoreObject</strong> до вызова <em>CreateSurface()</em>. Не волнуйтесь, мы к этому ещё вернемся при разборе функции <em>main()</em>.</p>
<p>Реализаций класса <em>VulkanWindowControl</em> всего две: <em>XCBControl</em> для Linux и <em>Win32Control</em> для Windows. Сначала мы рассмотрим версию для Linux.</p>
<pre><code>class XCBControl : public VulkanWindowControl
{
public:
    XCBControl();

    ~XCBControl();

    virtual bool Init(uint Width, uint Height);

    virtual VkSurfaceKHR CreateSurface(VkInstance&amp; inst);

 private:
    xcb_connection_t* m_pXCBConn;
    xcb_screen_t* m_pXCBScreen;
    xcb_window_t m_xcbWindow;
};</code></pre>
<p>Самая популярная оконная система на Linux - это, конечно же, XWindow. Она работает в клиент - серверной архитектуре. Сервер управляет экраном, клавиатурой и мышью. Клиентами являются приложения, которые хотят что-то вывести на экран. Они подключаются к серверу по протоколу X11 и отправляют запросы на создание окна, управление клавиатурой / мышью и прочее. Самыми часто встречаемыми реализациями протокола X11 являются Xlib и XCB, и они обе поддерживаются Vulkan. <a href="https://en.wikipedia.org/wiki/XCB">XCB</a> более современная, поэтому мы будем использовать её под Linux. <strong>XCBControl</strong> реализует класс <strong>VulkanWindowControl</strong> используя вызовы XCB. Напомню, что целью всего этого является создание окна ОС и подсоединение его к поверхности Vulkan. В результате Vulkan должен быть способен рендерить в это окно. Давайте начнем с создания окна:</p>
<pre><code>void XCBControl::Init(uint Width, uint Height)
{
    m_pXCBConn = xcb_connect(NULL, NULL);

    int error = xcb_connection_has_error(m_pXCBConn);

    if  (error) {
        printf(&quot;Error opening xcb connection error %d\n&quot;, error);
        assert(0);
    }

    printf(&quot;XCB connection opened\n&quot;);</code></pre>
<p>Первое что нам потребуется сделать - это подключиться к серверу XWindow. Я уверен что вы используете графический режим, поэтому сервер уже запущен в фоне. <em>xcb_connect()</em> открывает подключение к серверу. Она принимает два параметра: название сервера и указатель на желаемый номер экрана (его для нас заполнит библиотека XCB). XWindow очень гибок в настройке. Например, он позволяет запустить сервер на одной машине, а клиента на другой. А можно запустить сразу несколько серверов на одной машине. Для подключения к удаленному серверу потребуется его IP и номер экрана в специальном формате строки. А для запуска локально достаточно передать <em>NULL</em> в оба параметра.</p>
<p>Мы сохраняем в классе указатель на подключение, которое возвращает <em>xcb_connect()</em>. Функция всегда что-то возвращает, поэтому мы обязательно проверяем наличие ошибок с помощью функции <em>xcb_connectionn_has_error()</em> как показано выше.</p>
<pre><code>    const xcb_setup_t *pSetup = xcb_get_setup(m_pXCBConn);

    xcb_screen_iterator_t iter = xcb_setup_roots_iterator(setup);

    m_pXCBScreen = iter.data;

    printf(&quot;XCB screen %p\n&quot;, m_pXCBScreen);</code></pre>
<p>Сервер XWindow может управлять несколькими мониторами и запускать несколько экранов на каждом из них. Как раз на экране и запускаются приложения. Он имеет ширину, высоту, грубину цвета и прочие характеристики. Мы хотим получить доступ к текущему экрану, для чего нам потребуются два действия. Первое - это использовать функцию <em>xcb_get_setup()</em> для доступа к структуре <em>xcb_setup_t</em> с данными о соединении. В ней содержится большое количество информации о сервере. Среди прочего там есть список экранов. Для доступа к этому списку мы создаем итератор с помощью функции <em>xcb_setup_roots_iterator()</em>. В сложных приложениях тут должен быть код, который пробегает по списку экранов в поиске подходящего для приложения. А мы просто возьмём первый в списке. Экран можно получить следующим образом:</p>
<pre><code>    m_xcbWindow = xcb_generate_id(m_pXCBConn);</code></pre>
<p>Теперь мы готовы к созданию окна. Первым шагом мы генерируем <em>XID</em> - беззнаковое целое число, идентификатор всех ресурсов XWindow. Когда клиент подсоединяется к серверу, последний выделяет подмножество XID для этого клиента. Когда клиент хочет создать некоторый объект на сервере, он выделяет себе XID из разрешенного ему промежутка. Последующие вызовы функций могут использовать полученный XID. Это довольно новый подход. Обычно сервер говорит “эй, вот тебе новый объект и его номер XYZ”. А здесь клиент говорит “слушай, сервер, я хочу создать новый объект и вот его номер”. <em>xcb_generate_id()</em> генерирует XID для окна, а мы сохраняем его в свойство <em>m_xcbWindow</em>.</p>
<pre><code>    xcb_create_window(m_pXCBConn,             // соединение с сервером XWindow
      XCB_COPY_FROM_PARENT,                   // глубина цвета
      m_xcbWindow,                            // XID нового окна
      m_pXCBScreen-&gt;root,                     // родительское окно
      0,                                      // координата X
      0,                                      // координата Y
      Width,                                  // ширина окна
      Height,                                 // высота окна
      0,                                      // ширина границы
      XCB_WINDOW_CLASS_INPUT_OUTPUT,          // класс окна, не смог найти документации
      m_pXCBScreen-&gt;root_visual,              // определяет отображения цвета
      0,
      0);</code></pre>
<p>Функция <em>xcb_create_window()</em>, которая создает окно, принимает, ни много ни мало, 13 параметров. Я добавил немного комментариев к ним, большая часть из них очевидны. Больше этого я не буду объяснять. Поищите информацию в интернете, если оно вам надо.</p>
<pre><code>    xcb_map_window(m_pXCBConn, m_xcbWindow);
    xcb_flush (m_pXCBConn);
}</code></pre>
<p>Чтобы сделать окно видимым мы должны его отобразить и заставить сервер вывести буфер на экран. Вот этим два вызова выше и занимаются.</p>
<pre><code>VkSurfaceKHR XCBControl::CreateSurface(VkInstance&amp; inst)
{
    VkXcbSurfaceCreateInfoKHR surfaceCreateInfo = {};
    surfaceCreateInfo.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
    surfaceCreateInfo.connection = m_pXCBConn;
    surfaceCreateInfo.window = m_xcbWindow;

    VkSurfaceKHR surface;

    VkResult res = vkCreateXcbSurfaceKHR(inst, &amp;surfaceCreateInfo, NULL, &amp;surface);
    CHECK_VULKAN_ERROR(&quot;vkCreateXcbSurfaceKHR error %d\n&quot;, res);

    return surface;
}</code></pre>
<p>Последняя функция из класса <strong>XCBControl</strong>, на которую мы обратим внимание, - это <em>CreateSurface()</em>. По сути это декоратор функции Vulkan <em>vkCreateXcbSurfaceKHR()</em>. Мы заполняем структуру <strong>VkXcbSurfaceCreateInfoKHR</strong> указателем на соединение с сервером XWindow и созданным ранее окном. В ответ мы получим поверхность Vulkan, которую сразу же передаем назад вызвавшей функции.</p>
<p>Давайте теперь рассмотрим аналогичный класс для Windows:</p>
<pre><code>class Win32Control : public VulkanWindowControl
{
public:
    Win32Control(const char* pAppName);

    ~Win32Control();

    virtual void Init(uint Width, uint Height);

    virtual VkSurfaceKHR CreateSurface(VkInstance&amp; inst);

 private:

    HINSTANCE   m_hinstance;
    HWND        m_hwnd;
    std::wstring m_appName;
};</code></pre>
<p>Как вы видите, интерфейс для обеих ОС очень похож. По факту, <em>Init()</em> и <em>CreateSurface()</em> идентичны так как они виртуальные функции. Мы также добавили приватные свойства для записи специфических для Windows данных - <em>HINSTANE</em> и <em>HWND</em>.</p>
<pre><code>Win32Control::Win32Control(const char* pAppName)
{
    m_hinstance = GetModuleHandle(NULL);;
    assert(m_hinstance);
    m_hwnd = 0;
    **std::string s(pAppName)**;
    m_appName = **std::wstring(s.begin(), s.end())**;
}</code></pre>
<p>Выше показан конструктор класса <strong>Win32Control</strong>, который я привожу только для того, что бы вы знали как преобразовывается название окна из массива букв в <em>std::wstring</em>. Мы делаем это для функции <em>CreateWindowEx()</em>, которой название окна требуется в виде типа <em>LPCTSTR</em>. Стандартный класс <em>wstring</em> нам в этом пригодится.</p>
<pre><code>LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void Win32Control::Init(uint Width, uint Height)
{
    WNDCLASSEX wndcls = {};

    wndcls.cbSize = sizeof(wndcls);
    wndcls.lpfnWndProc = WindowProc;
    wndcls.hInstance = m_hinstance;
    wndcls.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndcls.lpszClassName = L&quot;ogldev&quot;;

    if (!RegisterClassEx(&amp;wndcls)) {
        DWORD error = GetLastError();
        OGLDEV_ERROR(&quot;RegisterClassEx error %d&quot;, error);
    }

    m_hwnd = CreateWindowEx(0,
                            L&quot;ogldev&quot;,                        // название
                            m_appName.c_str(),
                            WS_OVERLAPPEDWINDOW | WS_VISIBLE, // стиль окна
                            100, 100,                         // начальное положение
                            Width,
                            Height,
                            NULL,
                            NULL,
                            m_hinstance,
                            NULL);

    if (m_hwnd == 0) {
        DWORD error = GetLastError();
        OGLDEV_ERROR(&quot;CreateWindowEx error %d&quot;, error);
    }

    ShowWindow(m_hwnd, SW_SHOW);
}</code></pre>
<p>Код выше, который создает окно, я нашел на MSDN, поэтому я не буду сильно вдаваться в детали. Мы регистрируем окно через <em>RegisterClassEx()</em>. Окно будет иметь связь с функцией <em>WindowProc()</em> - обработчиком событий. Прямо сейчас мы используем стандартный обработчик, но в следующих уроках мы добавим больше деталей. Окно создается функцией <em>CreateWindowEx()</em> и, наконец, отображается через <em>ShowWindow()</em>.</p>
<pre><code>VkSurfaceKHR Win32Control::CreateSurface(VkInstance&amp; inst)
{
    VkWin32SurfaceCreateInfoKHR surfaceCreateInfo = {};
    surfaceCreateInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    surfaceCreateInfo.hinstance = m_hinstance;
    surfaceCreateInfo.hwnd = m_hwnd;

    VkSurfaceKHR surface;

    VkResult res = vkCreateWin32SurfaceKHR(inst, &amp;surfaceCreateInfo, NULL, &amp;surface);
    CHECK_VULKAN_ERROR(&quot;vkCreateXcbSurfaceKHR error %d\n&quot;, res);

    return surface;
}</code></pre>
<p><em>CreateSurface()</em> тоже очень похожа на аналог для Linux. Параметр <em>surfaceCreateInfo</em> здесь представляет собой экземпляр (и, конечно же, обработчики windows имеют другие типы).</p>
<pre><code>int main(int argc, char** argv)
{
    VulkanWindowControl* pWindowControl = NULL;
#ifdef WIN32
    pWindowControl = new Win32Control(pAppName);
#else
    pWindowControl = new XCBControl();
#endif
    pWindowControl-&gt;Init(WINDOW_WIDTH, WINDOW_HEIGHT);

    OgldevVulkanCore core(&quot;tutorial 50&quot;);
    core.Init(pWindowControl);

    return 0;
}</code></pre>
<p>Наконец мы подошли к связыванию всего кода в функции <em>main()</em>. Если есть желание, то вы можете начать отсюда и постепенно добавлять блоки кода, проверяя какие значения будет для них возвращать Vulkan. Всё в этой функции уже было подробно рассмотрено. Мы выделяем память для реализации класса <strong>VulkanWindowControl</strong> (для Linux или Windows), а затем создает и инициализируем объект <strong>OgldevVulkanCore</strong>. Теперь у нас есть связанная с окном ОС поверхность Vulkan, экземпляр Vulkan, устройство и база данных со всеми физическими устройствами.</p>
<p>Надеюсь что вам этот урок пригодился. Кстати, вместе с ним полагается футболка с надписью “Я написал тону кода на Vulkan, а получил пустое окно”. Действительно, мы проделали большой путь, а ничего так и не отрендерели. Но не отчаивайтесь. У нас есть базовая структура с несколькими объектами ядра Vulkan. В следующем уроке мы продолжим работать над ним, так что не переключайтесь.</p>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'ogltutor'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        </div>
    </div>
    <footer class="row">
        <div class="large-12 columns text-right">
            <hr>
            Шедевр, созданный с помощью <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            <br /><small><a href="https://github.com/triplepointfive/ogltutor">Исходный код</a></small>
        </div>
    </footer>
</body>
</html>
